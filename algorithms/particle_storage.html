

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Particle Storage &mdash; ppiclF Documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://dpzwick.github.io/ppiclF-doc/algorithms/particle_storage.html"/>
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Overlap Mesh" href="overlap_mesh.html" />
    <link rel="prev" title="Algorithms" href="../algorithms.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ppiclF
          

          
            
            <img src="../_static/ppiclF.gif" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                v1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../algorithms.html">Algorithms</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Particle Storage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bin-generation">Bin Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bin-to-rank-mapping">Bin-to-Rank Mapping</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="overlap_mesh.html">Overlap Mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="ghosts.html">Ghost Particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user.html">User Interface</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../acknowledge.html">Acknowledgements</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ppiclF</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../algorithms.html">Algorithms</a> &raquo;</li>
        
      <li>Particle Storage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="particle-storage">
<span id="part-storage"></span><h1>Particle Storage<a class="headerlink" href="#particle-storage" title="Permalink to this headline">¶</a></h1>
<p>Based on the coordinates (<span class="math notranslate nohighlight">\(\mathbf{X}\)</span>) of each individual particle, the particle domain may be decomposed into rectangular prisms in 3D (or simply rectangles in 2D). These rectangular prisms are called <strong>bins</strong>. The particles with coordinates inside each bin are stored together on the same processor in memory. Additionally, we make the following key assumption: <em>the total number of bins does not exceed the total number of processors</em>.</p>
<div class="section" id="bin-generation">
<h2>Bin Generation<a class="headerlink" href="#bin-generation" title="Permalink to this headline">¶</a></h2>
<p>In order to decompose the particle domain into bins, a recursive planar cutting is used. Given the bounds of the particle domain, which is the extrema coordinates of all particles in each dimension, the recursive planar cutting algorithm below is used.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while </span><span class="n">Condition</span> <span class="mi">1</span> <span class="nb">and </span><span class="n">Condition</span> <span class="mi">2</span> <span class="k">do</span>

<span class="k">   do </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span>
      <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

      <span class="k">if </span><span class="n">Condition</span> <span class="mi">1</span> <span class="nb">or </span><span class="n">Condition</span> <span class="mi">3</span> <span class="k">then</span>
<span class="k">         Continue</span>
<span class="k">      else</span>
<span class="k">         </span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
         <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>In the previous algorithm, we have defined <code class="code docutils literal notranslate"><span class="pre">d</span></code> to be the number of dimensions (either 2 or 3), <code class="code docutils literal notranslate"><span class="pre">c(i)</span></code> to be a counting array in the <code class="code docutils literal notranslate"><span class="pre">i</span></code> dimension, and <code class="code docutils literal notranslate"><span class="pre">f(i)</span></code> to be a flagging array in the <code class="code docutils literal notranslate"><span class="pre">i</span></code> dimension. The counting array specifies the number of bins in each dimension while the flagging array specifies if more bins can be added in the respective dimension.</p>
<p>Notice that there are three conditions that are checked upon each iteration. The conditions are:</p>
<ul class="simple">
<li><p>Condition 1 checks the key assumtption: if the total number of bins is less than or equal to the total number of processors.</p></li>
<li><p>Condition 2 deals with the size of the bins. Ideally, <code class="code docutils literal notranslate"><span class="pre">c(1)*c(2)*c(3)</span></code> would be as close to the total number of processors as possible. However, the user may specify a minimum interaction length between nearby particles, called <code class="code docutils literal notranslate"><span class="pre">W</span></code>. In the current algorithm, this requires the bin lengths in each dimension to be no smaller than <code class="code docutils literal notranslate"><span class="pre">W</span></code>. Thus, condition 2 checks if the length of the bins in every dimension is the smallest that it can be without being smaller than <code class="code docutils literal notranslate"><span class="pre">W</span></code>.</p></li>
<li><p>Condition 3 also deals with the size of the bins. However, condition 3 only checks if the length of the bins in a single <code class="code docutils literal notranslate"><span class="pre">i</span></code> dimension is the smallest that it can be without being smaller than <code class="code docutils literal notranslate"><span class="pre">W</span></code>.</p></li>
</ul>
<p>In 2D, an example of this is shown in the figure below.</p>
<div class="align-center figure" id="id1">
<img alt="../_images/bin_generation.png" src="../_images/bin_generation.png" />
<p class="caption"><span class="caption-text">Example of bin generation through recursive planar cutting.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>As is shown in the figure, the bin generation begins by bounding the particle domain, which is the region occupied by the rectangular prism whose planes are determined by the global maximum and minimum coordinates of the particles. Following this, the bins, which are demarcated by the dashed lines, are generated through the recursive planar cutting algorithm above. At the end of the process, different bin configurations are realized based on the number of processing ranks used. The resulting bin configurations are shown in the bottom of the figure above.</p>
<p>Additionally, below each bin distribution, the number of particles <span class="math notranslate nohighlight">\(N_p\)</span> per processing rank <span class="math notranslate nohighlight">\(R\)</span> is compared between the different cases. Note that since we have required there to only be one bin stored on each processor, <span class="math notranslate nohighlight">\(N_p/R\)</span> also refers to the number of particles per bin. Ideally, there would be exactly <span class="math notranslate nohighlight">\(N_p/R\)</span> particles on a processor. In the current method, the ideal number of particles per rank is relaxed to allow nearby particles to be locally grouped together in the same rank (or bin). Thus, in the current method we have a deviation from the ideal number of particles on each rank, with ranks having varying numbers of particles. In the figure, the maximum and minimum number of particles on each rank in ppiclF is shown.</p>
</div>
<div class="section" id="bin-to-rank-mapping">
<h2>Bin-to-Rank Mapping<a class="headerlink" href="#bin-to-rank-mapping" title="Permalink to this headline">¶</a></h2>
<p>Once the bins have been created, they are mapped to processing ranks. This includes mapping all the data that has coordinates which are found within the enclosing volume of each bin to the same processor. A single bin is described by the volume which it encloses. To reference a bin, the indices <span class="math notranslate nohighlight">\((i,j,k)\)</span> may be used, where <span class="math notranslate nohighlight">\(i = 0,...,c(1)-1\)</span>, <span class="math notranslate nohighlight">\(j = 0,...,c(2)-1\)</span>, and <span class="math notranslate nohighlight">\(k = 0,...,c(3)-1\)</span>. The volume which each bin encloses is</p>
<div class="math notranslate nohighlight">
\[\begin{split}x \in [L_{dx} + i L_{bx}, L_{dx} + (i+1) L_{bx}], \\ y \in [L_{dy} + j L_{by}, L_{dy} + (j+1) L_{by}], \\ z \in [L_{dz} + k L_{bz}, L_{dz} + (k+1) L_{bz}] ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{d*}\)</span> is the particle domain width in respective dimension and <span class="math notranslate nohighlight">\(L_{b*}\)</span> is the bin width in respective dimension (i.e., <span class="math notranslate nohighlight">\(L_{b*} = L_{d*}/c(*)\)</span>).</p>
<p>The bin-to-rank mapping, which determines which processing rank stores the data within a given bin, is then performed by mapping each bins indices <span class="math notranslate nohighlight">\((i,j,k)\)</span> to processing rank <span class="math notranslate nohighlight">\(n_{ID}\)</span> by</p>
<div class="math notranslate nohighlight">
\[n_{ID} = i + c(1) j + c(1)c(2)k.\]</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, David Zwick

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>