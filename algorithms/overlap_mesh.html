

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overlap Mesh &mdash; ppiclF Documentation</title>
  

  
  
  
  
    <link rel="canonical" href="https://dpzwick.github.io/ppiclF-doc/algorithms/overlap_mesh.html"/>
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Ghost Particles" href="ghosts.html" />
    <link rel="prev" title="Particle Storage" href="particle_storage.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> ppiclF
          

          
            
            <img src="../_static/ppiclF.gif" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                v1.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../algorithms.html">Algorithms</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="particle_storage.html">Particle Storage</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Overlap Mesh</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mapping">Mapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interpolation">Interpolation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#projection">Projection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ghosts.html">Ghost Particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user.html">User Interface</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../acknowledge.html">Acknowledgements</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ppiclF</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../algorithms.html">Algorithms</a> &raquo;</li>
        
      <li>Overlap Mesh</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overlap-mesh">
<span id="id1"></span><h1>Overlap Mesh<a class="headerlink" href="#overlap-mesh" title="Permalink to this headline">¶</a></h1>
<div class="section" id="mapping">
<h2>Mapping<a class="headerlink" href="#mapping" title="Permalink to this headline">¶</a></h2>
<p>In particle-in-cell simulations, the particles are often required to interact with an Eulerian mesh. Since the particle are tracked individually at discrete locations that do not necessarily coincide with a mesh, interactions between the particles and mesh must be handled carefully. We define two key opperations between the particles and the mesh:</p>
<ol class="arabic simple">
<li><p><strong>Interpolation</strong> - field quantities on the mesh are evaulated at the particle’s coordinates,</p></li>
<li><p><strong>Projection</strong> - particle quantities are filtered from the particle’s coordinates to the mesh.</p></li>
</ol>
<p>Both of these operations require the user to initially specify the coordinates of the mesh. In the current version of ppiclF, only element based hexahedral (or quad in 2D) meshes are supported.</p>
<p>The elements of the mesh are stored in memory according to the external program which calls ppiclF. For this reason, the elements need to be mapped to bins where the particles are stored. An example of this mapping is shown in the figure below.</p>
<div class="align-center figure" id="id4">
<img alt="../_images/bin_map.png" src="../_images/bin_map.png" />
<p class="caption"><span class="caption-text">Illustration of mapping overlapping mesh to bins.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>In the top left corner of the figure, a semicircular mesh is given. Particles handled by ppiclF are shown in the interior of the mesh. The four bins generated through the algorithm in the section <a class="reference internal" href="particle_storage.html#part-storage"><span class="std std-ref">Particle Storage</span></a> are also shown surrounding the particles. The particles within the same bin are mapped to the same processor as illustrated in through the coloring of bins in the bottom left corner of the figure.</p>
<p>The elements in the mesh are mapped to processing ranks in the top right of the figure. Note that the ppiclF library is independent of this mesh-to-rank mapping and this is handled in the external calling program. As is shown in the bottom right corner of the figure, the mesh elements which are spatially found within each bin belong to processing ranks that are not the same as the ranks which store the bin data. For this reason, the mesh and corresponding fields found within bins must be communicated between the processors that store the bins themselves. In this example, this results in:</p>
<ul class="simple">
<li><p>communication between rank 0 (bin 0) and overlap ranks 0, 1, and 3,</p></li>
<li><p>communication between rank 1 (bin 1) and overlap ranks 0, 2, and 3,</p></li>
<li><p>communication between rank 2 (bin 2) and overlap ranks 0 and 1,</p></li>
<li><p>communication between rank 3 (bin 3) and overlap ranks 0 and 2.</p></li>
</ul>
</div>
<div class="section" id="interpolation">
<span id="id2"></span><h2>Interpolation<a class="headerlink" href="#interpolation" title="Permalink to this headline">¶</a></h2>
<p>In order to interpolate fields from the mesh to the particle locations, the mesh coordinates and interpolated fields found within a bin are communicated to the processor which stores that bins data. Then, interpolation is performed locally.</p>
<p>The current supported interpolation method is element based, in that only the nodes of the mesh element which surround the particle is used to interpolate a field to the particle’s position. In most cases, this results in trilinear (or bilinear in 2D) interpolation being performed. However, spectral polynomial interpolation is also supported in which mapped Gauss-Lobatto-Legendre points within each element are used to evaluate the barycentric Lagrange polynomials at the particles coordinates.</p>
</div>
<div class="section" id="projection">
<span id="id3"></span><h2>Projection<a class="headerlink" href="#projection" title="Permalink to this headline">¶</a></h2>
<p>In order to project quantities from the particle locations to the mesh, each bin stores a copy of the mesh coordinates that are found within its volume. Then, particles are filtered to this mesh copy locally and then communicated back to the processing ranks in the original mesh-to-rank mapping so that the external program has access to the projected fields.</p>
<p>The projection opperation is simply a filtering opperation which is characterized by a kernel. The current supported projection kernels are the box and Gaussian kernels. The projection opperation is performed for any i particle quantity <span class="math notranslate nohighlight">\(A^{(i)}\)</span>, resulting in the projected field <span class="math notranslate nohighlight">\(a(\mathbf{x})\)</span>. In this case, <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> correspond to the mesh coordinates and <span class="math notranslate nohighlight">\(\mathbf{X}^{(i)}\)</span> is the i particle’s coordinates. Projection for all <span class="math notranslate nohighlight">\(N_p\)</span> particles is then computed by</p>
<div class="math notranslate nohighlight">
\[a(\mathbf{x}) = \sum_{i=1}^{N_p} A^{(i)} g_{\mathcal{M}}(|\mathbf{x} - \mathbf{X}^{(i)}|).\]</div>
<p>Here, <span class="math notranslate nohighlight">\(g_{\mathcal{M}}(r)\)</span> is the projection kernel. For the Gaussian kernel, we have</p>
<div class="math notranslate nohighlight">
\[g_{\mathcal{M}}(r) = \left(\sqrt{\pi}\sqrt{\delta_f^2/(4 \ln 2)}\right)^{-d} \exp \left(\dfrac{-r^2}{\delta_f^2/(4 \ln 2)}\right),\]</div>
<p>where the kernel is parameterized by the filter half-width <span class="math notranslate nohighlight">\(\delta_f\)</span> in <span class="math notranslate nohighlight">\(d\)</span> dimensions. Note that when <span class="math notranslate nohighlight">\(r = \delta_f/2\)</span>, the kernel has decayed to half of its <span class="math notranslate nohighlight">\(r = 0\)</span> value.</p>
<p>The box kernel on the other hand is</p>
<div class="math notranslate nohighlight">
\[\begin{split}g_{\mathcal{M}}(r) = \left\{\begin{array}{lr} \dfrac{1}{(4/3)^{d-2} \pi (\delta_f/2)^d}, &amp; r \leq \delta_f/2 \\ 0, &amp; r &gt; \delta_f/2 \end{array} \right.\end{split}\]</div>
<p>Similarly, the filter half-width defines the maximum point where distances <span class="math notranslate nohighlight">\(r &gt; \delta_f/2\)</span> are outside the filtering region. Note that due to the normalization of each filter, when the field <span class="math notranslate nohighlight">\(a(\mathbf{x})\)</span> is integrated over the entire volume <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> (or area in 2D) spanned by the mesh, the following relationship is preserved</p>
<div class="math notranslate nohighlight">
\[\int_{\mathcal{V}} a(\mathbf{x}) d\mathcal{V} = \sum_{i=1}^{N_p} A^{(i)}.\]</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, David Zwick

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>